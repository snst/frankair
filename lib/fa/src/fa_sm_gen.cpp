// Autogenerated with StateSmith
// User RenderConfig CFileTop text...
#include "fa_sm_gen.h"
// user IRenderConfigC.CFileIncludes: whatever you want to put in here.
#include "fa_sm_actions.h"
#include "fa_sm_decisions.h"
#include "fa_error.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

static void ROOT_enter(fa_sm_gen* self);
static void ROOT_exit(fa_sm_gen* self);
static void ROOT_ev_error(fa_sm_gen* self);
static void ROOT_ev_reboot(fa_sm_gen* self);
static void ROOT_ev_settings_changed(fa_sm_gen* self);

static void AUTO_enter(fa_sm_gen* self);
static void AUTO_exit(fa_sm_gen* self);
static void AUTO_ev_auto_sniff(fa_sm_gen* self);
static void AUTO_ev_auto_wait(fa_sm_gen* self);
static void AUTO_ev_update(fa_sm_gen* self);

static void ON_enter(fa_sm_gen* self);
static void ON_exit(fa_sm_gen* self);

static void SNIFF_enter(fa_sm_gen* self);
static void SNIFF_exit(fa_sm_gen* self);
static void SNIFF_ev_sniff_finished(fa_sm_gen* self);

static void WAIT_enter(fa_sm_gen* self);
static void WAIT_exit(fa_sm_gen* self);

static void ERROR_enter(fa_sm_gen* self);
static void ERROR_exit(fa_sm_gen* self);

static void MANUAL_enter(fa_sm_gen* self);
static void MANUAL_exit(fa_sm_gen* self);

static void OFF_enter(fa_sm_gen* self);
static void OFF_exit(fa_sm_gen* self);

// This function is used when StateSmith doesn't know what the active leaf state is at compile time due to sub states
// or when multiple states need to be exited.
static void exit_up_to_state_handler(fa_sm_gen* self, const fa_sm_gen_Func desired_state_exit_handler);

static void ROOT_ChoicePoint__transition(fa_sm_gen* self);

static void AUTO_ChoicePoint__transition(fa_sm_gen* self);


void fa_sm_gen_ctor(fa_sm_gen* self)
{
    memset(self, 0, sizeof(*self));
}

static void exit_up_to_state_handler(fa_sm_gen* self, const fa_sm_gen_Func desired_state_exit_handler)
{
    while (self->current_state_exit_handler != desired_state_exit_handler)
    {
        self->current_state_exit_handler(self);
    }
}

void fa_sm_gen_start(fa_sm_gen* self)
{
    ROOT_enter(self);
    // ROOT behavior
    // uml: TransitionTo(ROOT.InitialState)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.InitialState`.
        // ROOT.InitialState is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.InitialState behavior
        // uml: TransitionTo(ROOT.ChoicePoint())
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `ROOT.ChoicePoint()`.
            // ROOT.ChoicePoint() is a pseudo state and cannot have an `enter` trigger.
            
            // Finish transition by calling pseudo state transition function.
            ROOT_ChoicePoint__transition(self);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ROOT.InitialState
    } // end of behavior for ROOT
}

void fa_sm_gen_dispatch_event(fa_sm_gen* self, enum fa_sm_gen_EventId event_id)
{
    fa_sm_gen_Func behavior_func = self->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        self->ancestor_event_handler = NULL;
        behavior_func(self);
        behavior_func = self->ancestor_event_handler;
    }
}

const char* fa_sm_gen_state_id_to_string(const enum fa_sm_gen_StateId id)
{
    switch (id)
    {
        case fa_sm_gen_StateId_ROOT: return "ROOT";
        case fa_sm_gen_StateId_AUTO: return "AUTO";
        case fa_sm_gen_StateId_ON: return "ON";
        case fa_sm_gen_StateId_SNIFF: return "SNIFF";
        case fa_sm_gen_StateId_WAIT: return "WAIT";
        case fa_sm_gen_StateId_ERROR: return "ERROR";
        case fa_sm_gen_StateId_MANUAL: return "MANUAL";
        case fa_sm_gen_StateId_OFF: return "OFF";
        default: return "?";
    }
}

////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(fa_sm_gen* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[fa_sm_gen_EventId_EV_ERROR] = ROOT_ev_error;
    self->current_event_handlers[fa_sm_gen_EventId_EV_REBOOT] = ROOT_ev_reboot;
    self->current_event_handlers[fa_sm_gen_EventId_EV_SETTINGS_CHANGED] = ROOT_ev_settings_changed;
}

static void ROOT_exit(fa_sm_gen* self)
{
    // State machine root is a special case. It cannot be exited.
    (void)self;  // nothing to see here compiler. move along!
}

static void ROOT_ev_error(fa_sm_gen* self)
{
    // No ancestor state handles `ev_error` event.
    
    // ROOT behavior
    // uml: EV_ERROR [!isOverrideEnabled()] TransitionTo(ERROR)
    if (!isOverrideEnabled())
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ERROR`.
        ERROR_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = fa_sm_gen_StateId_ERROR;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for ROOT
}

static void ROOT_ev_reboot(fa_sm_gen* self)
{
    // No ancestor state handles `ev_reboot` event.
    
    // ROOT behavior
    // uml: EV_REBOOT / { smActionReboot(); } TransitionTo(OFF)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, ROOT_exit);
        
        // Step 2: Transition action: `smActionReboot();`.
        smActionReboot();
        
        // Step 3: Enter/move towards transition target `OFF`.
        OFF_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = fa_sm_gen_StateId_OFF;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for ROOT
}

static void ROOT_ev_settings_changed(fa_sm_gen* self)
{
    // No ancestor state handles `ev_settings_changed` event.
    
    // ROOT behavior
    // uml: EV_SETTINGS_CHANGED TransitionTo(ROOT.ChoicePoint())
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.ChoicePoint()`.
        // ROOT.ChoicePoint() is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        ROOT_ChoicePoint__transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for ROOT
}

static void ROOT_ChoicePoint__transition(fa_sm_gen* self)
{
    // ROOT.ChoicePoint() behavior
    // uml: 2. [isMode(controller_mode_t::kAuto)] TransitionTo(AUTO)
    if (isMode(controller_mode_t::kAuto))
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `AUTO`.
        AUTO_enter(self);
        
        // AUTO.InitialState behavior
        // uml: TransitionTo(SNIFF)
        {
            // Step 1: Exit states until we reach `AUTO` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `SNIFF`.
            SNIFF_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = fa_sm_gen_StateId_SNIFF;
            self->ancestor_event_handler = NULL;
            return;
        } // end of behavior for AUTO.InitialState
    } // end of behavior for ROOT.ChoicePoint()
    
    // ROOT.ChoicePoint() behavior
    // uml: 3. [isMode(controller_mode_t::kManual)] TransitionTo(MANUAL)
    if (isMode(controller_mode_t::kManual))
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `MANUAL`.
        MANUAL_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = fa_sm_gen_StateId_MANUAL;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for ROOT.ChoicePoint()
    
    // ROOT.ChoicePoint() behavior
    // uml: else TransitionTo(OFF)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `OFF`.
        OFF_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = fa_sm_gen_StateId_OFF;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for ROOT.ChoicePoint()
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state AUTO
////////////////////////////////////////////////////////////////////////////////

static void AUTO_enter(fa_sm_gen* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = AUTO_exit;
    self->current_event_handlers[fa_sm_gen_EventId_EV_AUTO_SNIFF] = AUTO_ev_auto_sniff;
    self->current_event_handlers[fa_sm_gen_EventId_EV_AUTO_WAIT] = AUTO_ev_auto_wait;
    self->current_event_handlers[fa_sm_gen_EventId_EV_UPDATE] = AUTO_ev_update;
}

static void AUTO_exit(fa_sm_gen* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[fa_sm_gen_EventId_EV_AUTO_SNIFF] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[fa_sm_gen_EventId_EV_AUTO_WAIT] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[fa_sm_gen_EventId_EV_UPDATE] = NULL;  // no ancestor listens to this event
}

static void AUTO_ev_auto_sniff(fa_sm_gen* self)
{
    // No ancestor state handles `ev_auto_sniff` event.
    
    // AUTO behavior
    // uml: EV_AUTO_SNIFF TransitionTo(SNIFF)
    {
        // Step 1: Exit states until we reach `AUTO` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, AUTO_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `SNIFF`.
        SNIFF_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = fa_sm_gen_StateId_SNIFF;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for AUTO
}

static void AUTO_ev_auto_wait(fa_sm_gen* self)
{
    // No ancestor state handles `ev_auto_wait` event.
    
    // AUTO behavior
    // uml: EV_AUTO_WAIT TransitionTo(WAIT)
    {
        // Step 1: Exit states until we reach `AUTO` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, AUTO_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WAIT`.
        WAIT_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = fa_sm_gen_StateId_WAIT;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for AUTO
}

static void AUTO_ev_update(fa_sm_gen* self)
{
    // No ancestor state handles `ev_update` event.
    
    // AUTO behavior
    // uml: EV_UPDATE TransitionTo(AUTO.ChoicePoint())
    {
        // Step 1: Exit states until we reach `AUTO` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, AUTO_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `AUTO.ChoicePoint()`.
        // AUTO.ChoicePoint() is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        AUTO_ChoicePoint__transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for AUTO
}

static void AUTO_ChoicePoint__transition(fa_sm_gen* self)
{
    // AUTO.ChoicePoint() behavior
    // uml: 1. [isRoomRelHumidityBelowMinimum()] TransitionTo(WAIT)
    if (isRoomRelHumidityBelowMinimum())
    {
        // Step 1: Exit states until we reach `AUTO` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WAIT`.
        WAIT_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = fa_sm_gen_StateId_WAIT;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for AUTO.ChoicePoint()
    
    // AUTO.ChoicePoint() behavior
    // uml: 2. [isAbsHumidityDeltaTooLowToRun()] TransitionTo(WAIT)
    if (isAbsHumidityDeltaTooLowToRun())
    {
        // Step 1: Exit states until we reach `AUTO` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WAIT`.
        WAIT_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = fa_sm_gen_StateId_WAIT;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for AUTO.ChoicePoint()
    
    // AUTO.ChoicePoint() behavior
    // uml: 3. [isRoomTempBelowDesiredMinTempAndFreshTempBelowRoomTemp()] TransitionTo(WAIT)
    if (isRoomTempBelowDesiredMinTempAndFreshTempBelowRoomTemp())
    {
        // Step 1: Exit states until we reach `AUTO` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `WAIT`.
        WAIT_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = fa_sm_gen_StateId_WAIT;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for AUTO.ChoicePoint()
    
    // AUTO.ChoicePoint() behavior
    // uml: else TransitionTo(AUTO.ChoicePoint())
    {
        // Step 1: Exit states until we reach `AUTO` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `AUTO.ChoicePoint()`.
        // AUTO.ChoicePoint() is a pseudo state and cannot have an `enter` trigger.
        
        // AUTO.ChoicePoint() behavior
        // uml: 4. [isRoomTempBelowDesiredMaxTempAndFreshTempOverRoomTemp()] / { smActionModeOnMax(); } TransitionTo(ON)
        if (isRoomTempBelowDesiredMaxTempAndFreshTempOverRoomTemp())
        {
            // Step 1: Exit states until we reach `AUTO` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `smActionModeOnMax();`.
            smActionModeOnMax();
            
            // Step 3: Enter/move towards transition target `ON`.
            ON_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = fa_sm_gen_StateId_ON;
            self->ancestor_event_handler = NULL;
            return;
        } // end of behavior for AUTO.ChoicePoint()
        
        // AUTO.ChoicePoint() behavior
        // uml: else / { smActionModeOnAdjustMainFan(); } TransitionTo(AUTO.ChoicePoint())
        {
            // Step 1: Exit states until we reach `AUTO` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `smActionModeOnAdjustMainFan();`.
            smActionModeOnAdjustMainFan();
            
            // Step 3: Enter/move towards transition target `AUTO.ChoicePoint()`.
            // AUTO.ChoicePoint() is a pseudo state and cannot have an `enter` trigger.
            
            // AUTO.ChoicePoint() behavior
            // uml: 4. [isFanLevelReducedToOff()] TransitionTo(WAIT)
            if (isFanLevelReducedToOff())
            {
                // Step 1: Exit states until we reach `AUTO` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `WAIT`.
                WAIT_enter(self);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                self->state_id = fa_sm_gen_StateId_WAIT;
                self->ancestor_event_handler = NULL;
                return;
            } // end of behavior for AUTO.ChoicePoint()
            
            // AUTO.ChoicePoint() behavior
            // uml: else TransitionTo(ON)
            {
                // Step 1: Exit states until we reach `AUTO` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: ``.
                
                // Step 3: Enter/move towards transition target `ON`.
                ON_enter(self);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                self->state_id = fa_sm_gen_StateId_ON;
                self->ancestor_event_handler = NULL;
                return;
            } // end of behavior for AUTO.ChoicePoint()
        } // end of behavior for AUTO.ChoicePoint()
    } // end of behavior for AUTO.ChoicePoint()
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ON
////////////////////////////////////////////////////////////////////////////////

static void ON_enter(fa_sm_gen* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = ON_exit;
    
    // ON behavior
    // uml: enter / { smActionModeOnAdjustFrost();\nfire_ev(EV_UPDATE, settings->controller_interval_sec); }
    {
        // Step 1: execute action `smActionModeOnAdjustFrost();\nfire_ev(EV_UPDATE, settings->controller_interval_sec);`
        smActionModeOnAdjustFrost();
        self->vars.eventSM.send(fa_sm_gen_EventId_EV_UPDATE, (self->vars.settings->controller_interval_sec * 1000U));
    } // end of behavior for ON
}

static void ON_exit(fa_sm_gen* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = AUTO_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SNIFF
////////////////////////////////////////////////////////////////////////////////

static void SNIFF_enter(fa_sm_gen* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = SNIFF_exit;
    self->current_event_handlers[fa_sm_gen_EventId_EV_SNIFF_FINISHED] = SNIFF_ev_sniff_finished;
    
    // SNIFF behavior
    // uml: enter / { smActionModeSniff();\nfire_ev(EV_SNIFF_FINISHED, settings->sniff.sniff_sec); }
    {
        // Step 1: execute action `smActionModeSniff();\nfire_ev(EV_SNIFF_FINISHED, settings->sniff.sniff_sec);`
        smActionModeSniff();
        self->vars.eventSM.send(fa_sm_gen_EventId_EV_SNIFF_FINISHED, (self->vars.settings->sniff.sniff_sec * 1000U));
    } // end of behavior for SNIFF
}

static void SNIFF_exit(fa_sm_gen* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = AUTO_exit;
    self->current_event_handlers[fa_sm_gen_EventId_EV_SNIFF_FINISHED] = NULL;  // no ancestor listens to this event
}

static void SNIFF_ev_sniff_finished(fa_sm_gen* self)
{
    // No ancestor state handles `ev_sniff_finished` event.
    
    // SNIFF behavior
    // uml: EV_SNIFF_FINISHED TransitionTo(AUTO.ChoicePoint())
    {
        // Step 1: Exit states until we reach `AUTO` state (Least Common Ancestor for transition).
        SNIFF_exit(self);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `AUTO.ChoicePoint()`.
        // AUTO.ChoicePoint() is a pseudo state and cannot have an `enter` trigger.
        
        // AUTO.ChoicePoint() behavior
        // uml: 1. [isAbsHumidityDeltaTooLowToStart()] TransitionTo(WAIT)
        if (isAbsHumidityDeltaTooLowToStart())
        {
            // Step 1: Exit states until we reach `AUTO` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `WAIT`.
            WAIT_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = fa_sm_gen_StateId_WAIT;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for AUTO.ChoicePoint()
        
        // AUTO.ChoicePoint() behavior
        // uml: else TransitionTo(AUTO.ChoicePoint())
        {
            // Step 1: Exit states until we reach `AUTO` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `AUTO.ChoicePoint()`.
            // AUTO.ChoicePoint() is a pseudo state and cannot have an `enter` trigger.
            
            // Finish transition by calling pseudo state transition function.
            AUTO_ChoicePoint__transition(self);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for AUTO.ChoicePoint()
    } // end of behavior for SNIFF
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state WAIT
////////////////////////////////////////////////////////////////////////////////

static void WAIT_enter(fa_sm_gen* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = WAIT_exit;
    
    // WAIT behavior
    // uml: enter / { smActionModeWait();\nfire_ev(EV_AUTO_SNIFF, settings->sniff.wait_sec); }
    {
        // Step 1: execute action `smActionModeWait();\nfire_ev(EV_AUTO_SNIFF, settings->sniff.wait_sec);`
        smActionModeWait();
        self->vars.eventSM.send(fa_sm_gen_EventId_EV_AUTO_SNIFF, (self->vars.settings->sniff.wait_sec * 1000U));
    } // end of behavior for WAIT
}

static void WAIT_exit(fa_sm_gen* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = AUTO_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ERROR
////////////////////////////////////////////////////////////////////////////////

static void ERROR_enter(fa_sm_gen* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = ERROR_exit;
    
    // ERROR behavior
    // uml: enter / { smActionModeError(); }
    {
        // Step 1: execute action `smActionModeError();`
        smActionModeError();
    } // end of behavior for ERROR
}

static void ERROR_exit(fa_sm_gen* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state MANUAL
////////////////////////////////////////////////////////////////////////////////

static void MANUAL_enter(fa_sm_gen* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MANUAL_exit;
    
    // MANUAL behavior
    // uml: enter / { smActionModeManual(); }
    {
        // Step 1: execute action `smActionModeManual();`
        smActionModeManual();
    } // end of behavior for MANUAL
}

static void MANUAL_exit(fa_sm_gen* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state OFF
////////////////////////////////////////////////////////////////////////////////

static void OFF_enter(fa_sm_gen* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = OFF_exit;
    
    // OFF behavior
    // uml: enter / { smActionModeOff(); }
    {
        // Step 1: execute action `smActionModeOff();`
        smActionModeOff();
    } // end of behavior for OFF
}

static void OFF_exit(fa_sm_gen* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


